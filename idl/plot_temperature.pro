;------------------------------------------------------------------------
;
;  File:    plot_temperature.pro
;
;  Purpose:
;    IDL procedure to read in particle data from HDF5 files generated by
;      a parallel OOPIC run.  One then can plot the temperature.
;
;  Overview:
;
;    Argument list:
;
;    base_name  -> a string that specifies the first input
;                  data file (base_name.txt) and is also used to name 
;                  output files.
;    num_procs  -> number of processors
;    XLabel     -> a string that specifies the coordinate component, e.g. 'x'.
;    XLabel2    -> a string that specifies 2nd coordinate component, e.g. 'y'.
;    ScaleFlag  -> a flag to specify the scaling for length, i.e. of q:
;                        0 -> no scaling
;                        1 -> length scale = c/omega_0 (the laser frequency)
;                        2 -> length scale = c/omega_p (the plasma frequency)
;    ScaleInput -> this is irrelevant for ScaleFlag = 0,
;                          or omega_0 for ScaleFlag = 1,
;          plasma density in [1/cm^3] for ScaleFlag = 2
;
;  Copyright (c) 2003 by Tech-X Corporation.  All rights reserved.
;
;  Change log:
;  1.00 (Bruhwiler 10-24-2003) Initial code.
;
;------------------------------------------------------------------------


pro plot_temperature, base_name, num_procs, XLabel, YLabel, ScaleFlag, ScaleInput

; *****************************************************************
; Names for files and labels
; *****************************************************************

; Specify the text, restore and postscript file names
restore_file  = base_name  + '.dat'

xcontour_file = base_name  + '_vx_rms.ps'
ycontour_file = base_name  + '_vy_rms.ps'
vcontour_file  = base_name  + '_v_rms.ps'

xlineout_file = base_name  + '_lineout_vx_avg.ps'
ylineout_file = base_name  + '_lineout_vy_avg.ps'

x2lineout_file = base_name  + '_lineout_vx_rms.ps'
y2lineout_file = base_name  + '_lineout_vy_rms.ps'

txlineout_file = base_name  + '_lineout_tx.ps'
tylineout_file = base_name  + '_lineout_ty.ps'

tlineout_file  = base_name  + '_lineout_temp.ps'
vlineout_file  = base_name  + '_lineout_v_rms.ps'


; *****************************************************************
; Specify which plots you want (1) or don't want (0):
; *****************************************************************

doTxContour = 1
doTyContour = 1
doTContour  = 1

; Specify non-default window sizes for contour, surface, show3d plots
; Dimension is pixels for the window command
x_win_ccon = 1000
y_win_ccon =  350
; Dimension is cm for the device command
x_device = 25.0
y_device = 12.0

; *****************************************************************
; Set a factor (between 0 and 1) specifying which row of data
;    (r=constant or y=constant) that you want for the lineout plot.
r_factor = 0.5

; *****************************************************************
; Parse the ascii data file or restore from the binary IDL file
; *****************************************************************

; If the restore file exists, then use it.
; Otherwise, parse the text file:

spawn, "ls " + restore_file, check_file, /sh
;print, 'The "check"   file is: ', check_file
;print, 'The "restore" file is: ', restore_file

if (check_file(0) eq restore_file) then begin

  print,'Reading from the restore file: ' + restore_file + ' ...'
  restore, filename = restore_file

endif else begin

; First, we have to determine the total number of particles to be parsed.

  print, ' '
  print, 'Calculating total number of particles to be parsed from the hdf5 files named'
  print, '   ' + base_name + '_p*.h5  ...'
  print, ' '
  total_num_ptcls = 0
  for i_loop=0, num_procs-1 do begin           ; beginning of major for loop

    hdf5_file = base_name + '_p' + strtrim(i_loop,2) + '.h5'
    file_id = h5f_open(hdf5_file)

    group_id     = h5g_open(file_id, '/electrons')
    attribute_id = h5a_open_name(group_id, 'nPtclGrp')
    num_groups = h5a_read(attribute_id)
    h5a_close, attribute_id
    h5g_close, group_id

    for j=0, num_groups-1 do begin           ; loop over the particle groups

      dataset = '/electrons/pGrp' + strtrim(j,2)
      dataset_id   = h5d_open(file_id, dataset+'/ptcls')
      dataspace_id = h5d_get_space(dataset_id)
      npoints = h5s_get_simple_extent_npoints(dataspace_id)
      h5d_close, dataset_id

      total_num_ptcls = total_num_ptcls + npoints/5

    endfor      ; end of sub-loop over particle groups

; Close the file
    h5f_close, file_id

  endfor        ; end of major loop over num_procs
  print, 'The total number of particles to be parsed is: ', total_num_ptcls
  print, ' '




; *****************************************************************
; Define the 1D particle data arrays

  x  = dindgen(total_num_ptcls)
  y  = dindgen(total_num_ptcls)
  vx = dindgen(total_num_ptcls)
  vy = dindgen(total_num_ptcls)
  vz = dindgen(total_num_ptcls)
  wt = dindgen(total_num_ptcls)

; Here we actually read the particle data out of the HDF5 files
  num_parsed = 0
  for i_loop=0, num_procs-1 do begin           ; beginning of major for loop

    hdf5_file = base_name + '_p' + strtrim(i_loop,2) + '.h5'

    print,'Parsing the hdf5 file: ' + hdf5_file + ' ...'
    file_id = h5f_open(hdf5_file)

    group_id     = h5g_open(file_id, '/electrons')
    attribute_id = h5a_open_name(group_id, 'nPtclGrp')
    num_groups = h5a_read(attribute_id)
    h5a_close, attribute_id
    h5g_close, group_id

    for j=0, num_groups-1 do begin           ; loop over the particle groups

      dataset = '/electrons/pGrp' + strtrim(j,2)

      group_id     = h5g_open(file_id, dataset)
      attribute_id = h5a_open_name(group_id, 'np2c')
      ptcl_weight  = h5a_read(attribute_id)
      h5a_close, attribute_id
      h5g_close, group_id

      dataset_id   = h5d_open(file_id, dataset+'/ptcls')
      ptcl = h5d_read(dataset_id)
      h5d_close, dataset_id

      num_ptcl   = n_elements(ptcl) / 5
      num_prev   = num_parsed
      num_parsed = num_parsed + num_ptcl

; Load the raw data into individual arrays.
       x(num_prev:num_parsed-1) = ptcl(0,0:num_ptcl-1)
       y(num_prev:num_parsed-1) = ptcl(1,0:num_ptcl-1)
      vx(num_prev:num_parsed-1) = ptcl(2,0:num_ptcl-1)
      vy(num_prev:num_parsed-1) = ptcl(3,0:num_ptcl-1)
      vz(num_prev:num_parsed-1) = ptcl(4,0:num_ptcl-1)
      wt(num_prev:num_parsed-1) = ptcl_weight

    endfor      ; end of sub-loop over particle groups

; Close the file
    h5f_close, file_id

  endfor        ; end of major loop over num_procs

  print, ' '
  print, 'Number of parsed particles is: ', num_parsed
  print, 'Number of elements in x() is:  ', n_elements(x)

; Save so IDL doesn't have to repeatedly parse the HDF5 file
  print, ' '
  print, 'Now generating an IDL restore file with the name: ' + restore_file + ' ...'
  save, x, y, vx, vy, vz, wt, filename = restore_file

endelse


; *****************************************************************
; Scale the data so it corresponds to the desired units
; *****************************************************************
;
q_label  = '!3' + XLabel
q_label2 = '!3' + YLabel
if ( ScaleFlag eq 1 ) then begin
  ;
  ; scale the length using as a c/omega_0 as a length scale
  ; 
  omega_0 = ScaleInput
  lengthScale = 3.0e8/omega_0
  x = x / lengthScale
  y = y / lengthScale
endif else if (ScaleFlag eq 2) then begin
  ;
  ; scale lengths to the plasma wavenumber k_p
  ; 
  density = ScaleInput
  omega_p = 2. * 3.14 * 9000. * sqrt(density)
  x = x * omega_p / 2.998e+08
  y = y * omega_p / 2.998e+08
endif else begin
  ;
  ; this is the default case of no scaling 
  ;
endelse

; Remove the relativistic factor gamma from the velocities:
 c     = 2.998e+08
 c_sq  = c*c
 v_sq  = vx*vx + vy*vy
 gamma = sqrt(1. + v_sq / c_sq)
 vx = vx / gamma
 vy = vy / gamma

;
; *****************************************************************
; set the min and max values of the data
; *****************************************************************
;
autoscale = 1
if (autoscale eq 1 ) then begin 
  x_min = min(x)
  x_max = max(x)
  y_min = min(y)
  y_max = max(y)
endif else begin
  x_min  =  0.0
  x_max  =  5.3
  y_min =  0.0
  y_max =  2.0
endelse

x_min  =  2.0
y_min =  0.5 * y_max - 5.
y_max =  y_min + 10.


;
; *****************************************************************
; create the spatial grid
; *****************************************************************

numGridsX  = 512
numGridsY =  96

delta_x = (x_max - x_min) / numGridsX
delta_y = (y_max - y_min) / numGridsY

x_grid = dblarr(numGridsX)
y_grid = dblarr(numGridsY)
for i = 0, numGridsX-1  do begin
  x_grid[i] = (i+0.5) * delta_x
end
for i = 0, numGridsY-1  do begin
  y_grid[i] = (i+0.5) * delta_y
end


; *****************************************************************
; Loop for rendering 2-D color contour plot on screen and to a file
; *****************************************************************

if (doTxContour eq 1) then begin
 
; calculate gridded temperature for the 1st velocity component
  print, ' '
  print, 'Now gridding up the temperature to load rms velocity v_x_rms...'
  v_x_rms = temperature_2d(x, y, vx, wt, numGridsX, numGridsY, $
                           XAXIS=xax, YAXIS=yax,               $
                           VMEAN=v_x_avg, DV_MAX=dv_x_max,     $
                           N_MACRO=n_macro)

; Now rotate by 180 degrees to compare with Brad Shadwick's results
  v_x_rms = reverse(v_x_rms, 1)
  v_x_avg = reverse(v_x_avg, 1)
  v_x_ratio = reverse(v_x_ratio, 1)

  dv_x_ratio = dv_x_max
  ind = where(dv_x_max GE 2.e+06)
  dv_x_ratio(ind) = v_x_rms(ind) / dv_x_max(ind)
  ind = where(dv_x_max LT 2.e+06) 
  dv_x_ratio(ind) = 0.

; let's smooth the results a little
;  v_x_rms = smooth(v_x_rms, 3, /EDGE_TRUNCATE)
;  v_x_avg = smooth(v_x_avg, 3, /EDGE_TRUNCATE)

; Calculate the corresponding temperature
  T_x  = 0.511e+06 * (v_x_rms/2.998e+08)^2
;  T_x  = smooth(T_x,     3, /EDGE_TRUNCATE)

; sometimes it's helpful to have a log scale to see what is going on
  T_x_log = alog10( T_x + 1.0e-10 * max(T_x) )

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Color contour plot will appear in window ', window_number
  window, window_number, xsize=x_win_ccon, ysize=ywin_ccon, RETAIN=2
  xcontour_i = 0
  xcontour_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label  + ' (c/!9w!3!d0!N)'
      y_label = q_label2 + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label  + ' (c/!9w!3!dp!N)'
      y_label = q_label2 + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D color contour plot to file ' + xcontour_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label  + ' (c/!4x!3!d0!N)'
      y_label = q_label2 + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label  + ' (c/!4x!3!dp!N)'
      y_label = q_label2 + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D color contour plot to the screen...'
  endelse

; Load in the RAINBOW color table
  loadct, 13

  contour, v_x_rms, x_grid, y_grid, thick=2, /xs, /ys, nlevels=40, $
           xtitle=x_label, ytitle=y_label, /fill

; Load in the B-W LINEAR color table
  loadct, 0 

  contour, v_x_rms, x_grid, y_grid, thick=2, /xs, /ys, nlevels=40, $
           xtitle=x_label, ytitle=y_label, /fill, /NoErase, /NoData

  xyout_str = 'v_x_rms [m/s]'
  xyouts, 0.25, 0.85, xyout_str, /NORMAL

; rendering to screen is done.  here we render to ps file
  if (xcontour_i eq 0) then begin
    xcontour_i = 1
    set_plot, 'PS', /copy
    device, filename = xcontour_file, /color, bits_per_pixel=8, $
            xsize=x_device, ysize=ywin_device, /LANDSCAPE
    goto, xcontour_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (xcontour_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

; *****************************************************************
; Now for the corresponding lineout

; Grab the desired row of data (here it is along the r=0 axis)
; Specify which row (fixed value of r) of grid points you will
;   want to use for the lineout plot
  r_row = fix(numGridsY*r_factor*.9)
  T_x_line     = T_x(*,     r_row)
  v_x_rms_line = v_x_rms(*, r_row)
  v_x_avg_line = v_x_avg(*, r_row)

  T_x_line     = smooth(T_x_line,     3, /EDGE_TRUNCATE)
  v_x_rms_line = smooth(v_x_rms_line, 3, /EDGE_TRUNCATE)
;  v_x_avg_line = smooth(v_x_avg_line, 3, /EDGE_TRUNCATE)

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Line plot will appear in window ', window_number
  window, window_number, RETAIN=2
  xlineout_i = 0
  xlineout_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D lineout plot to file ' + xlineout_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D lineout plot for the screen...'
  endelse

  y_label = '<v_x> [m/s]'
  plot,  x_grid, v_x_avg_line, thick=2, /xs, xtitle=x_label, ytitle=y_label, $
         YRANGE=[-1.0e+08,1.0e+08]

; rendering to screen is done.  here we render to ps file
  if (xlineout_i eq 0) then begin
    xlineout_i = 1
    set_plot, 'PS', /copy
    device, filename = xlineout_file, /color, bits_per_pixel=8, xsize=12.0, ysize=10.0
    goto, xlineout_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (xlineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

;****************************************************************************

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Line plot will appear in window ', window_number
  window, window_number, RETAIN=2
  x2lineout_i = 0
  x2lineout_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D lineout plot to file ' + x2lineout_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D lineout plot for the screen...'
  endelse

  y_label = 'v_x_rms [m/s]'
  plot,  x_grid, v_x_rms_line, thick=2, /xs, xtitle=x_label, ytitle=y_label, $
         YRANGE=[0.,1e+07]

; rendering to screen is done.  here we render to ps file
  if (x2lineout_i eq 0) then begin
    x2lineout_i = 1
    set_plot, 'PS', /copy
    device, filename = x2lineout_file, /color, bits_per_pixel=8, xsize=12.0, ysize=10.0
    goto, x2lineout_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (x2lineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

;****************************************************************************

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Line plot will appear in window ', window_number
  window, window_number, RETAIN=2
  txlineout_i = 0
  txlineout_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D lineout plot to file ' + txlineout_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D lineout plot for the screen...'
  endelse

  y_label = 'T_x [eV]'
  plot,  x_grid, T_x_line, thick=2, /xs, xtitle=x_label, ytitle=y_label, $
         YRANGE=[0.,500.]

; rendering to screen is done.  here we render to ps file
  if (txlineout_i eq 0) then begin
    txlineout_i = 1
    set_plot, 'PS', /copy
    device, filename = txlineout_file, /color, bits_per_pixel=8, xsize=12.0, ysize=10.0
    goto, txlineout_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (txlineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif


; *****************************************************************
; Loop for rendering 2-D color contour plot on screen and to a file
; *****************************************************************

if (doTyContour eq 1) then begin
 
; calculate gridded temperature for the 1st velocity component
  print, ' '
  print, 'Now gridding up the temperature to load rms velocity v_y_rms...'
  v_y_rms = temperature_2d(x, y, vy, wt, numGridsX, numGridsY, $
                           XAXIS=xax, YAXIS=yax,               $
                           VMEAN=v_y_avg, DV_MAX=dv_y_max,     $
                           N_MACRO=n_macro)

; Now rotate by 180 degrees to compare with Brad Shadwick's results
  v_y_rms = reverse(v_y_rms, 1)
  v_y_avg = reverse(v_y_avg, 1)

; let's smooth the results a little
;  v_y_rms = smooth(v_y_rms, 3, /EDGE_TRUNCATE)
;  v_y_avg = smooth(v_y_avg, 3, /EDGE_TRUNCATE)

; Calculate the corresponding temperature
  T_y  = 0.511e+06 * (v_y_rms/2.998e+08)^2
;  T_y  = smooth(T_y,     3, /EDGE_TRUNCATE)

; sometimes it's helpful to have a log scale to see what is going on
  T_y_log = alog10( T_y + 1.0e-10 * max(T_y) )

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Color contour plot will appear in window ', window_number
  window, window_number, xsize=x_win_ccon, ysize=ywin_ccon, RETAIN=2
  ycontour_i = 0
  ycontour_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label  + ' (c/!9w!3!d0!N)'
      y_label = q_label2 + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label  + ' (c/!9w!3!dp!N)'
      y_label = q_label2 + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D color contour plot to file ' + ycontour_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label  + ' (c/!4x!3!d0!N)'
      y_label = q_label2 + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label  + ' (c/!4x!3!dp!N)'
      y_label = q_label2 + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D color contour plot to the screen...'
  endelse

; Load in the RAINBOW color table
  loadct, 13

  contour, v_y_rms, x_grid, y_grid, thick=2, /xs, /ys, nlevels=40, $
           xtitle=x_label, ytitle=y_label, /fill

; Load in the B-W LINEAR color table
  loadct, 0 

  contour, v_y_rms, x_grid, y_grid, thick=2, /xs, /ys, nlevels=40, $
           xtitle=x_label, ytitle=y_label, /fill, /NoErase, /NoData

  xyout_str = 'v_y_rms [m/s]'
  xyouts, 0.25, 0.85, xyout_str, /NORMAL

; rendering to screen is done.  here we render to ps file
  if (ycontour_i eq 0) then begin
    ycontour_i = 1
    set_plot, 'PS', /copy
    device, filename = ycontour_file, /color, bits_per_pixel=8, $
            xsize=x_device, ysize=ywin_device, /LANDSCAPE
    goto, ycontour_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (ycontour_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

; *****************************************************************
; Now for the corresponding lineout

; Grab the desired row of data (here it is along the r=0 axis)
; Specify which row (fixed value of r) of grid points you will
;   want to use for the lineout plot
  r_row = fix(numGridsY*r_factor)
  T_y_line     = T_y(*,     r_row)
  v_y_rms_line = v_y_rms(*, r_row)
  v_y_avg_line = v_y_avg(*, r_row)

  T_y_line     = smooth(T_y_line,     3, /EDGE_TRUNCATE)
  v_y_rms_line = smooth(v_y_rms_line, 3, /EDGE_TRUNCATE)
;  v_y_avg_line = smooth(v_y_avg_line, 3, /EDGE_TRUNCATE)

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Line plot will appear in window ', window_number
  window, window_number, RETAIN=2
  ylineout_i = 0
  ylineout_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D lineout plot to file ' + ylineout_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D lineout plot for the screen...'
  endelse

  y_label = '<v_y> [m/s]'
  plot,  x_grid, v_y_avg_line, thick=2, /xs, xtitle=x_label, ytitle=y_label, $
         YRANGE=[-1.0e+08,1.0e+08]

; rendering to screen is done.  here we render to ps file
  if (ylineout_i eq 0) then begin
    ylineout_i = 1
    set_plot, 'PS', /copy
    device, filename = ylineout_file, /color, bits_per_pixel=8, xsize=12.0, ysize=10.0
    goto, ylineout_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (ylineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

;****************************************************************************

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Line plot will appear in window ', window_number
  window, window_number, RETAIN=2
  y2lineout_i = 0
  y2lineout_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D lineout plot to file ' + y2lineout_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D lineout plot for the screen...'
  endelse

  y_label = 'v_y_rms [m/s]'
  plot,  x_grid, v_y_rms_line, thick=2, /xs, xtitle=x_label, ytitle=y_label, $
         YRANGE=[0.,3.0e+07]

; rendering to screen is done.  here we render to ps file
  if (y2lineout_i eq 0) then begin
    y2lineout_i = 1
    set_plot, 'PS', /copy
    device, filename = y2lineout_file, /color, bits_per_pixel=8, xsize=12.0, ysize=10.0
    goto, y2lineout_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (y2lineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

;****************************************************************************

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Line plot will appear in window ', window_number
  window, window_number, RETAIN=2
  tylineout_i = 0
  tylineout_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D lineout plot to file ' + tylineout_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D lineout plot for the screen...'
  endelse

  y_label = 'T_y [eV]'
  plot,  x_grid, T_y_line, thick=2, /xs, xtitle=x_label, ytitle=y_label, $
         YRANGE=[0.,5000.]

; rendering to screen is done.  here we render to ps file
  if (tylineout_i eq 0) then begin
    tylineout_i = 1
    set_plot, 'PS', /copy
    device, filename = tylineout_file, /color, bits_per_pixel=8, xsize=12.0, ysize=10.0
    goto, tylineout_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (tylineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif


; *****************************************************************
; Loop for rendering 2-D color contour plot on screen and to a file
; *****************************************************************

if (doTContour eq 1) then begin
 
; calculate gridded temperature for the 1st velocity component
  print, ' '
  print, 'Now calculating the total rms velocity and temperature...'
  temp  = T_x + T_y
  v_rms = 2.998e+08 * sqrt(temp/0.511e+06)

; sometimes it's helpful to have a log scale to see what is going on
  temp_log = alog10( temp + 1.0e-10 * max(temp) )

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Color contour plot will appear in window ', window_number
  window, window_number, xsize=x_win_ccon, ysize=ywin_ccon, RETAIN=2
  vcontour_i = 0
  vcontour_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label  + ' (c/!9w!3!d0!N)'
      y_label = q_label2 + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label  + ' (c/!9w!3!dp!N)'
      y_label = q_label2 + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D color contour plot to file ' + vcontour_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label  + ' (c/!4x!3!d0!N)'
      y_label = q_label2 + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label  + ' (c/!4x!3!dp!N)'
      y_label = q_label2 + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D color contour plot to the screen...'
  endelse

; Load in the RAINBOW color table
  loadct, 13

  contour, v_rms, x_grid, y_grid, thick=2, /xs, /ys, nlevels=40, $
           xtitle=x_label, ytitle=y_label, /fill

; Load in the B-W LINEAR color table
  loadct, 0 

  contour, v_rms, x_grid, y_grid, thick=2, /xs, /ys, nlevels=40, $
           xtitle=x_label, ytitle=y_label, /fill, /NoErase, /NoData

  xyout_str = 'v_total_rms [m/s]'
  xyouts, 0.25, 0.85, xyout_str, /NORMAL

; rendering to screen is done.  here we render to ps file
  if (vcontour_i eq 0) then begin
    vcontour_i = 1
    set_plot, 'PS', /copy
    device, filename = vcontour_file, /color, bits_per_pixel=8, $
            xsize=x_device, ysize=ywin_device, /LANDSCAPE
    goto, vcontour_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (vcontour_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

; *****************************************************************
; Now for the corresponding lineout

; Grab the desired row of data (here it is along the r=0 axis)
; Specify which row (fixed value of r) of grid points you will
;   want to use for the lineout plot
  r_row = fix(numGridsY*r_factor)
  temp_line  = temp(*,  r_row)
  v_rms_line = v_rms(*, r_row)

 temp_line  = smooth(temp_line,  3, /EDGE_TRUNCATE)
 v_rms_line = smooth(v_rms_line, 3, /EDGE_TRUNCATE)

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Line plot will appear in window ', window_number
  window, window_number, RETAIN=2
  vlineout_i = 0
  vlineout_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D lineout plot to file ' + vlineout_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D lineout plot for the screen...'
  endelse

  y_label = 'v_total_rms [m/s]'
  plot,  x_grid, v_rms_line, thick=2, /xs, xtitle=x_label, ytitle=y_label, $
         YRANGE=[0.,3.0e+07]

; rendering to screen is done.  here we render to ps file
  if (vlineout_i eq 0) then begin
    vlineout_i = 1
    set_plot, 'PS', /copy
    device, filename = vlineout_file, /color, bits_per_pixel=8, xsize=12.0, ysize=10.0
    goto, vlineout_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (vlineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

;****************************************************************************

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Line plot will appear in window ', window_number
  window, window_number, RETAIN=2
  tlineout_i = 0
  tlineout_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!9w!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!9w!3!dp!N)'
    endif 
    print, ' '
    print, 'Writing the 2D lineout plot to file ' + tlineout_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q_label + ' (c/!4x!3!d0!N)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q_label + ' (c/!4x!3!dp!N)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D lineout plot for the screen...'
  endelse

  y_label = 'Temperature [eV]'
  plot,  x_grid, temp_line, thick=2, /xs, xtitle=x_label, ytitle=y_label, $
         YRANGE=[0.,5000.]

; rendering to screen is done.  here we render to ps file
  if (tlineout_i eq 0) then begin
    tlineout_i = 1
    set_plot, 'PS', /copy
    device, filename = tlineout_file, /color, bits_per_pixel=8, xsize=12.0, ysize=10.0
    goto, tlineout_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (tlineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif

; *****************************************************************
; Final clean-up
; *****************************************************************

; Stop here so that all variables will still be in scope.
 stop

; All done.
end
