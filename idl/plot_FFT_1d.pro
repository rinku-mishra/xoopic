; NAME:      plot_FFT_1d
;
; PURPOSE:   IDL procedure to read in FFT power spectra density data from
;            a .txt file generated by dumping ASCII data from either the
;            XOOPIC or the OOPIC Pro GUI.
;
; CATEGORY:
;
; CALLING SEQUENCE:
;   plot_fft_1d, f_name, x_name, y_name, z_name
;
; INPUTS:
;   f_name:    string to specify base name of data file
;   x_name:    string to specify horizontal axis (must be "x" or "z")
;   y_name:    string to specify vertical   axis (must be "y" or "r")
;   z_name:    string to specify field component 
;              (must be "x", "y", "z", "r", or "phi")
;
; OPTIONAL INPUTS:     None.
;
; KEYWORD PARAMETERS:  None.
;
; OUTPUTS:             None.
;
; OPTIONAL OUTPUTS:    None.
;
; COMMON BLOCKS:       None.
;
; SIDE EFFECTS:        None.
;
; RESTRICTIONS: 
;
;    The XOOPIC and OOPIC Pro .txt files generally have some lines of text.
;    You need to delete any such text lines, leaving only the data.
;
;    XOOPIC and OOPIC Pro can generate both 1-D and 2-D FFT plots.
;    This procedure is for use with the 1-D FFT plots only.
;
; PROCEDURE:
;
; EXAMPLE:
;   plot_fft_1d, "ey_fft_file", "x", "y", "y"
;
; MODIFICATION HISTORY:
;   Oct 20, 2001:  initially adapted from the plot_FFT pro file (DLB)
;
;   Version: $Id: plot_FFT_1d.pro 1778 2001-10-23 18:06:10Z bruhwile $
;
;   Copyright (c) 2001 by Tech-X Corporation.  All rights reserved.


pro plot_FFT_1d, base_name, x1Label, x2Label, EcomponentLabel

; *****************************************************************
; Set flag for log plots
; *****************************************************************

; If log_plot_flag is nonzero, then this procedure will take the
; logarithm of the z-data

log_plot_flag = 1


; *****************************************************************
; Names for files and labels
; *****************************************************************

; Specify the text, restore and postscript file names
text_file    = base_name + '.txt'
restore_file = base_name + '.dat'

if (log_plot_flag eq 0) then begin
  ps_ccon_file = base_name + '_colorcon_lin.ps'
  ps_cont_file = base_name + '_contour_lin.ps'
  ps_surf_file = base_name + '_surface_lin.ps'
  ps_line_file = base_name + '_integral_lin.ps'
  ps_tier_file = base_name + '_tiered_lin.ps'
endif else begin
  ps_ccon_file = base_name + '_colorcon_log.ps'
  ps_cont_file = base_name + '_contour_log.ps'
  ps_surf_file = base_name + '_surface_log.ps'
  ps_line_file = base_name + '_integral_log.ps'
  ps_tier_file = base_name + '_tiered_log.ps'
endelse

; *****************************************************************
; Specify which plots you want (1) or don't want (0):
; *****************************************************************

doIntegral = 1
doColorCon = 1
doContour = 0
doSurface = 0
doShow3D = 0

; *****************************************************************
; Specify minimum and/or maximum values for x1 and x2:
; *****************************************************************

; Set auto_scale_lambda to 1 for automatic scaling of the horizontal
;    axis (wavelength).
; lambda is in units of nm
;
auto_scale_lambda = 0
x1min = 469
x1max = 833

; Set auto_scale_y to 1 for automatic scaling of the y
;    axis (transverse position).
; y is in units of microns
;
auto_scale_y = 1
; x2min = 0.
; x2max = 200.

; Set auto_scale_count to 1 for automatic scaling of the vertical
;    axis ("count" or power spectral density).
; count is in "arbitrary units" (must be scaled)
;
auto_scale_count = 1
; x3min = 1.
; x3max = 13780.


; *****************************************************************
; Parse the ascii data file or restore from the binary IDL file
; *****************************************************************

; Check to see if the "restore" file has been created:
spawn, "ls | grep " + restore_file, check_file, /sh
;print, 'The "check"   file is: ', check_file
;print, 'The "restore" file is: ', restore_file

; If the restore file exists, then use it.
if (check_file(0) eq restore_file) then begin

  print, ' '
  print,'Reading from the restore file: ' + restore_file + ' ...'
  restore, filename = restore_file

; Otherwise, parse the text file:
endif else begin

  print, ' '
  print,'Parsing the text file: ' + text_file + ' ...'
  data=read_ascii(text_file)

  print, ' '
  print, 'Here is the size and shape of the raw data:'
  help,data.field1

; *****************************************************************
; Initial manipulation of the data
; *****************************************************************

; Load the raw data into individual arrays.
;
; Use the following for ascii data dumped from XOOPIC
;  y1d =data.field1(2,*)
;  k1d =data.field1(3,*)
;  temp=data.field1(4,*)
;
; Use the following for ascii data dumped from OOPIC Pro
  y1d =data.field1(2,*)
  k1d =data.field1(3,*)
  temp=data.field1(4,*)

  print, ' '
  print, 'y1d, k1d, temp are the columns of the raw data:'
  help,y1d
  help,k1d
  help,temp
  print, 'y1d(0) y1d(1) y1d(n-1) = ', y1d(0),y1d(1),y1d(n_elements(y1d)-1)
  print, 'k1d(0) k1d(1) k1d(n-1) = ', k1d(0),k1d(1),k1d(n_elements(k1d)-1)

; Extract the unique values for r and z grid points
  ytemp=y1d(sort(y1d))
  y=ytemp(uniq(ytemp))
  ktemp=k1d(sort(k1d))
  kx=ktemp(uniq(ktemp))

  ny = n_elements(y)
  nx = n_elements(kx)

; Create a 2-D array that holds the gridded surface data
  print, ' '
  print, 'Rearranging the structure of the raw data (can take a while)....'
  print, "max_temp = ", max(temp)
  print, "min_temp = ", min(temp)
  psd = dblarr(nx,ny)
  for i = 0, nx-1 do begin
     psd(i,*) = temp[i*ny:(i+1)*ny-1]
  endfor
  print, '  ...done! '

; strip out the kx(0) data, because this is not relevant,
;   and it leads to lambda(0)=inf below.
  kx = kx(1:nx-1)
  psd = psd(1:nx-1,*)
  nx = nx-1

  print, ' '
  print, 'nx = ', nx
  print, 'ny = ', ny
  print, ' '
  print, 'kx(0) kx(1) kx(', nx-1, ') = ', kx(0),kx(1),kx(nx-1)
  print, 'y(0)  y(1)  y( ', ny-1, ') = ', y(0), y(1), y(ny-1)
  print, ' '
  help,psd
  print, "max_psd = ", max(psd)
  print, "min_psd = ", min(psd)

; Save so IDL doesn't have to repeatedly parse the ASCII file
  save, y,kx,psd,nx,ny, filename = restore_file

; *****************************************************************
; Here is the end of the if/then/else construct for parsing.
; *****************************************************************
endelse


; *****************************************************************
; Define the axes and title labels
; *****************************************************************
;
z_label = '!3PSD(E!Dz!N)'
x_label = 'wavelength (nm)'
y_label = 'PSD (arbitrary units)'


; *****************************************************************
; Convert from wavenumber k to lambda
; *****************************************************************
;
; f(lambda)*d_lambda = f(k)*d_k ==> f(lambda) = f(k)*(d_k/d_lambda)
;

two_pi = 16.*acos(0.)
lambda = two_pi / kx
dk_dlambda = kx * kx / two_pi

for i = 0, nx-1 do begin
  psd(i,*) = psd(i,*) * dk_dlambda(i)
endfor

; *****************************************************************
; Normalize psd    to arbitrary units
; Normalize lambda from m to nm
; Normalize y      from m to microns
; *****************************************************************
  psdFactor = 1.0
  psd    = psdFactor * psd
  lambda = 1.0e+09   * lambda
  y      = 1.0e+06   * y

print, ' '
print, 'After normalization of the y, lambda and "count" arrays:'
print, ' '
print, 'nx = ', nx
print, 'ny = ', ny
print, ' '
print, 'lambda(0) lambda(1) lambda(', nx-1, ') = ', lambda(0),lambda(1),lambda(nx-1)
print, '     y(0)      y(1)      y(', ny-1, ') = ',      y(0),     y(1),     y(ny-1)
print, ' '
print, 'min_psd max_psd  = ', min(psd), max(psd)

print, ' '
print, 'These are the min and max values of the original data:'

x1min_data = lambda(0)
x1max_data = lambda(nx-1)
x2min_data = y(0)
x2max_data = y(ny-1)

if (auto_scale_lambda ne 0) then begin
  x1min = x1min_data
  x1max = x1max_data
endif

if (auto_scale_y ne 0) then begin
  x2min = x2min_data
  x2max = x2max_data
endif

; Sum up the integrated (over y) spectrum
;
psd_1d = dblarr(nx)
for i = 0, nx-1 do begin
  psd_1d(i) = 0.
  for j = 0, ny-1 do begin
    psd_1d(i) = psd_1d(i) + psd(i,j)
  endfor
endfor
max_tmp = max(psd_1d)
psd_1d = psd_1d * max(psd) / max_tmp

x3min_data = min(psd_1d)
x3max_data = max(psd_1d)

print, ' '
help, psd_1d
print, 'min_psd_1d = ', x3min_data
print, 'max_psd_1d = ', x3max_data

if (auto_scale_count ne 0) then begin
  x3min = x3min_data
  x3max = x3max_data
endif

print, ' '
print, 'These are the specified min and max values:'

help,x1min
help,x1max
help,x2min
help,x2max
help,x3min
help,x3max

; *****************************************************************
; Surface plots don't support xrange/yrange, so truncate the data:
; *****************************************************************
if ( (x1min gt x1min_data) or (x2min gt x2min_data) ) then begin
  struct_A = array_cut(lambda, y, psd, x1min, x2min)
  lambda = struct_A.xnew
  y      = struct_A.ynew
  psd    = struct_A.znew

  nx = n_elements(lambda)
  ny = n_elements(y)

  print, ' '
  print, 'After applying the specified x1min and x2min --'
  print, 'nx = ', nx
  print, 'ny = ', ny
  print, ' '
  print, 'lambda(0) lambda(1) lambda(', nx-1, ') = ', lambda(0),lambda(1),lambda(nx-1)
  print, '     y(0)      y(1)      y(', ny-1, ') = ',      y(0),     y(1),     y(ny-1)
endif

if ( (x1max lt x1max_data) or (x2max lt x2max_data) ) then begin
  struct_A = array_cut_max(lambda, y, psd, x1max, x2max)
  z  = struct_A.xnew
  r  = struct_A.ynew
  psd = struct_A.znew

  nz = n_elements(z)
  nr = n_elements(r)

  print, ' '
  print, 'After applying the specified x1max and x2max --'
  print, 'nz = ', nz
  print, 'nr = ', nr
  print, 'z(0) z(1) z(', nz-1, ') = ', z(0),z(1),z(nz-1)
  print, 'r(0) r(1) r(', nr-1, ') = ', r(0),r(1),r(nr-1)
endif


; *****************************************************************
; Repeat simple plot loop for generating 2-D lineout plots.
; *****************************************************************

if (doIntegral eq 1) then begin

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Integrated spectrum will appear in window ', window_number
  window, window_number
  lineout_i = 0
  lineout_jump:

; Load in the STD GAMMA-II color table
  loadct, 5

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    print, ' '
    print, 'Writing the integrated spectrum plot to file ' + ps_line_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
    print, ' '
    print, 'Rendering the integrated spectrum plot for the screen...'
  endelse

if (log_plot_flag eq 0) then begin
  plot, lambda, psd_1d, thick=2, /xs, xtitle=x_label, ytitle=z_label, xrange=[x1min,x1max]
endif else begin
  plot_io, lambda, psd_1d, thick=2, /xs, xtitle=x_label, ytitle=z_label, xrange=[x1min,x1max]
endelse

; rendering to screen is done.  here we render to ps file
  if (lineout_i eq 0) then begin
    lineout_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_line_file, /color, bits_per_pixel=8
    goto, lineout_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (lineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif

stop

; *****************************************************************
; Create a 2-D color map appropriate for the surface
; *****************************************************************

; Create a 2D array that specifies the color for each grid point
if (log_plot_flag eq 0) then begin
  psd_color=psd-min(psd)
endif else begin
  psd_log = alog(psd)
  psd_color=psd_log-min(psd_log)
endelse
psd_color=psd_color/max(psd_color)
psd_color=psd_color*255.


; *****************************************************************
; Loop for rendering 2-D color contour plot on screen and to a file
; *****************************************************************

if (doColorCon eq 1) then begin

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Color contour plot will appear in window ', window_number
  window, window_number
  ccontour_i = 0
  ccontour_jump:

; Load in the STD GAMMA-II color table
  loadct, 5

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q1_label + ' (!9w!3!d0!N/c)'
      y_label = q2_label + ' (!9w!3!d0!N/c)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q1_label + ' (!9w!3!dp!N/c)'
      y_label = q2_label + ' (!9w!3!dp!N/c)'
    endif 
    print, ' '
    print, 'Writing the 2D color contour plot to file ' + ps_ccon_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q1_label + ' (!4x!3!d0!N/c)'
      y_label = q2_label + ' (!4x!3!d0!N/c)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q1_label + ' (!4x!3!dp!N/c)'
      y_label = q2_label + ' (!4x!3!dp!N/c)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D color contour plot to the screen...'
  endelse

if (log_plot_flag eq 0) then begin
  contour, psd, z, r, thick=2, /xs, /ys, nlevels=100, xtitle=x_label, ytitle=y_label, /fill
endif else begin
  contour, psd_log, z, r, thick=2, /xs, /ys, nlevels=100, xtitle=x_label, ytitle=y_label, /fill
endelse

; rendering to screen is done.  here we render to ps file
  if (ccontour_i eq 0) then begin
    ccontour_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_ccon_file, /color, bits_per_pixel=8
    goto, ccontour_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (ccontour_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif



; *****************************************************************
; Loop for rendering 2-D B&W contour plot on screen and to a file
; *****************************************************************

if (doContour eq 1) then begin

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Contour plot will appear in window ', window_number
  window, window_number
  contour_i = 0
  contour_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q1_label + ' (!9w!3!d0!N/c)'
      y_label = q2_label + ' (!9w!3!d0!N/c)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q1_label + ' (!9w!3!dp!N/c)'
      y_label = q2_label + ' (!9w!3!dp!N/c)'
    endif 
    print, ' '
    print, 'Writing the 2D b&w contour plot to file ' + ps_cont_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q1_label + ' (!4x!3!d0!N/c)'
      y_label = q2_label + ' (!4x!3!d0!N/c)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q1_label + ' (!4x!3!dp!N/c)'
      y_label = q2_label + ' (!4x!3!dp!N/c)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D b&w contour plot to the screen...'
  endelse
  
  print, 'min_x1  = ' , min(z)
  print, 'max_x1  = ' , max(z)
  print, 'min_x2  = ' , min(r)
  print, 'max_x2  = ' , max(r)

if (log_plot_flag eq 0) then begin
  contour, psd, z, r, thick=2, /xs, /ys, nlevels=4, xtitle=x_label, ytitle=y_label
endif else begin
  contour, psd_log, z, r, thick=2, /xs, /ys, nlevels=4, xtitle=x_label, ytitle=y_label
endelse


; rendering to screen is done.  here we render to ps file
  if (contour_i eq 0) then begin
    contour_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_cont_file
    goto, contour_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (contour_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif


; *****************************************************************
; Loop for rendering color surface plot on screen and to a file
; *****************************************************************

if (doSurface eq 1) then begin

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Color surface plot will appear in window ', window_number
  window, window_number
  surface_i = 0
  surface_jump:

; Load in the STD GAMMA-II color table
  loadct, 5

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q1_label + ' (!9w!3!d0!N/c)'
      y_label = q2_label + ' (!9w!3!d0!N/c)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q1_label + ' (!9w!3!dp!N/c)'
      y_label = q2_label + ' (!9w!3!dp!N/c)'
    endif 
    print, ' '
    print, 'Writing the color surface plot to file ' + ps_surf_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0 
    if ( ScaleFlag eq 1 ) then begin
      x_label = q1_label + ' (!4x!3!d0!N/c)'
      y_label = q2_label + ' (!4x!3!d0!N/c)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q1_label + ' (!4x!3!dp!N/c)'
      y_label = q2_label + ' (!4x!3!dp!N/c)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the color surface plot to the screen...'
  endelse

;  xAng = 90;
;  zAng = 0;
  xAng = 50;
  zAng = 30;

if (log_plot_flag eq 0) then begin
  surface, psd, z, r, thick=2, /xs, /ys, ax=xAng, az=zAng, shades=psd_color, $
           xtitle=x_label, ytitle=y_label, ztitle=z_label
endif else begin
  surface, psd, z, r, thick=2, /xs, /ys, ax=xAng, az=zAng, shades=psd_color, $
           xtitle=x_label, ytitle=y_label, ztitle=z_label, /zlog
endelse

; rendering to screen is done.  here we render to ps file
  if (surface_i eq 0) then begin
    surface_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_surf_file, /color, bits_per_pixel=8
    goto, surface_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (surface_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif


; *****************************************************************
; Repeat simple plot loop for generating fancy 3-tiered plot.
; *****************************************************************

if (doShow3D eq 1) then begin

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Three-tiered plot will appear in window ', window_number
  window, window_number
  three_tiered_i = 0
  three_tiered_jump:

; Load in the STD GAMMA-II color table
  loadct, 5

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    if ( ScaleFlag eq 1 ) then begin
      x_label = q1_label + ' (!9w!3!d0!N/c)'
      y_label = q2_label + ' (!9w!3!d0!N/c)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q1_label + ' (!9w!3!dp!N/c)'
      y_label = q2_label + ' (!9w!3!dp!N/c)'
    endif 
    print, ' '
    print, 'Writing 3-tiered surface/contour plot to file ' + ps_tier_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    if ( ScaleFlag eq 1 ) then begin
      x_label = q1_label + ' (!4x!3!d0!N/c)'
      y_label = q2_label + ' (!4x!3!d0!N/c)'
    endif else if ( ScaleFlag eq 2 ) then begin
      x_label = q1_label + ' (!4x!3!dp!N/c)'
      y_label = q2_label + ' (!4x!3!dp!N/c)'
    endif 
    device,decomposed=0
    print, ' '
    print, 'Rendering the 3-tiered surface/contour plot to the screen...'
  endelse

  surface_struct = { shades:psd_color, xtitle:x_label, ytitle:y_label, ztitle:z_label, $
                     xstyle:1, ystyle:1, zstyle:1}
  contour_struct = { nlevels:6, xstyle:1, ystyle:1, zstyle:1}
  show3, psd, z, r, e_surface=surface_struct, e_contour=contour_struct

; rendering to screen is done.  here we render to ps file
  if (three_tiered_i eq 0) then begin
    three_tiered_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_tier_file, /color, bits_per_pixel=8
    goto, three_tiered_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (three_tiered_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif


; *****************************************************************
; Final clean-up
; *****************************************************************

; Stop here so that all variables will still be in scope.
stop

; All done.
end
