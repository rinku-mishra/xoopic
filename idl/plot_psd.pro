; NAME:      plot_FFT
;
; PURPOSE:   IDL procedure to read in a field surface data from a .txt file
;            generated by dumping ASCII data from the OOPICPro gui.
;
; CATEGORY:
;
; CALLING SEQUENCE:
;   plot_psd, f_name, x_name, y_name, z_name, ScaleFlag, ScaleInput
;
; INPUTS:
;   f_name:    string to specify base name of data file
;   x_name:    string to specify horizontal axis (must be "x" or "z")
;   y_name:    string to specify vertical   axis (must be "y" or "r")
;   z_name:    string to specify field component 
;              (must be "x", "y", "z", "r", or "phi")
;  ScaleFlag:  a flag to specify the scaling for length, i.e. of q:
;                  0 -> no scaling
;                  1 -> length scale = c/omega_0 (the laser frequency)
;                  2 -> length scale = 1/Kp (the plasma wave vector)
;  ScaleInput; irrelevant for ScaleFlag = 0, 
;                  omega_0 for ScaleFlag = 1,
;                  plasma density in [1/cm^3] for ScaleFlag = 2  
;
; OPTIONAL INPUTS:     None.
;
; KEYWORD PARAMETERS:  None.
;
; OUTPUTS:             None.
;
; OPTIONAL OUTPUTS:    None.
;
; COMMON BLOCKS:       None.
;
; SIDE EFFECTS:        None.
;
; RESTRICTIONS: 
;
;    The XOOPIC .txt files generally have some lines of text.  You
;      need to delete any such text lines, leaving only the data.
;
;    The argument base_name is a string that specifies the input
;      data file (base_name.txt) and is also used to name output files.
;
;    This procedure is specifically for use with the Ex data, but it
;      could be easily modified for any other type of surface data:
;      a) Rename the _file and _label variables appropriately.
;      b) Look for the "convert" comment below and change the scaling
;         of the data to something appropriate for the desired units.
;
; PROCEDURE:
;
; EXAMPLE:
;   plot_blueshift, "ey_fft_file", "x", "y", "y", 1, 1.77e14
;
; MODIFICATION HISTORY:
;   Nov  7, 2000:  original code (DLB)
;   May  1, 2001:  some generalization (DAD)
;   May 10, 2001:  renamed, with many changes (DLB)
;
;   Version: $Id: plot_psd.pro 1926 2002-06-19 16:52:47Z dad $
;
;   Copyright (c) 2000-2001 by Tech-X Corporation.  All rights reserved.


pro plot_psd, base_name, x1Label, x2Label, EcomponentLabel, ScaleFlag, ScaleInput

; *****************************************************************
; Set flag for log plots
; *****************************************************************

; If log_plot_flag is nonzero, then this procedure will take the
; logarithm of the z-data

log_plot_flag = 1


; *****************************************************************
; Names for files and labels
; *****************************************************************

; Specify the text, restore and postscript file names
text_file    = base_name + '.txt'
restore_file = base_name + '.dat'

if (log_plot_flag eq 0) then begin
  ps_ccon_file = base_name + '_colorcon_lin.ps'
  ps_cont_file = base_name + '_contour_lin.ps'
  ps_surf_file = base_name + '_surface_lin.ps'
  ps_line_file = base_name + '_lineout_lin.ps'
  ps_integral_file = base_name + '_integral_lin.ps'
  ps_tier_file = base_name + '_tiered_lin.ps'
endif else begin
  ps_ccon_file = base_name + '_colorcon_log.ps'
  ps_cont_file = base_name + '_contour_log.ps'
  ps_surf_file = base_name + '_surface_log.ps'
  ps_line_file = base_name + '_lineout_log.ps'
  ps_integral_file = base_name + '_integral_log.ps'
  ps_tier_file = base_name + '_tiered_log.ps'
endelse

; *****************************************************************
; Specify which plots you want (1) or don't want (0):
; *****************************************************************

doShow3D   = 0
doSurface  = 0
doLineout  = 0
doIntegral = 1
doContour  = 0
doColorCon = 0

; *****************************************************************
; Parse the ascii data file or restore from the binary IDL file
; *****************************************************************

; Check to see if the "restore" file has been created:
spawn, "ls | grep " + restore_file, check_file, /sh
;print, 'The "check"   file is: ', check_file
;print, 'The "restore" file is: ', restore_file

; If the restore file exists, then use it.
if (check_file(0) eq restore_file) then begin

  print, ' '
  print,'Reading from the restore file: ' + restore_file + ' ...'
  restore, filename = restore_file

; Otherwise, parse the text file:
endif else begin

  print, ' '
  print,'Parsing the text file: ' + text_file + ' ...'
  data=read_ascii(text_file)

  print, ' '
  print, 'Here is the size and shape of the raw data:'
  help,data.field1

; *****************************************************************
; Initial manipulation of the data
; *****************************************************************

; Load the raw data into individual arrays.
  z1d =data.field1(0,*)
  r1d =data.field1(1,*)
  ez1d=data.field1(2,*)

  print, ' '
  print, 'z1d, r1d, ez1d are the columns of the raw data:'
  help,z1d
  help,r1d
  help,ez1d
  print, 'z1d(0) z1d(1) z1d(n-1) = ', z1d(0),z1d(1),z1d(n_elements(z1d)-1)
  print, 'r1d(0) r1d(1) r1d(n-1) = ', r1d(0),r1d(1),r1d(n_elements(r1d)-1)

; Extract the unique values for r and z grid points
  ztemp=z1d(sort(z1d))
  z=ztemp(uniq(ztemp))
  rtemp=r1d(sort(r1d))
  r=rtemp(uniq(rtemp))

  nz = n_elements(z)
  nr = n_elements(r)

  print, ' '
  print, 'z and r contain only the unique values of the original arrays:'
  help,z
  help,r
  print, 'nz = ', nz
  print, 'nr = ', nr
  print, 'z(0) z(1) z(', nz-1, ') = ', z(0),z(1),z(nz-1)
  print, 'r(0) r(1) r(', nr-1, ') = ', r(0),r(1),r(nr-1)

; Create a 2-D array that holds the gridded surface data
  print, ' '
  print, 'Creating ez from tri_surf() of the raw data (takes a while)....'
  help, ez1d
  help, z1d
  help, r1d
  print, "max_ez1d = ", max(ez1d)
  print, "min_ez1d = ", min(ez1d)
  nx=nz
  ny=nr
  ez = dblarr(nx,ny)
  for i = 0, nx-1 do begin
        ez(i,*) = ez1d[i*ny:(i+1)*ny-1]
        ;;;for j = 0, ny-1 do begin
        ;;;        ez(i,j) = ez1d[i*ny+j]
        ;;;endfor
  endfor
  print, '  ...done! '
  help,ez
  print, "max_ez = ", max(ez)
  print, "min_ez = ", min(ez)

; Save so IDL doesn't have to repeatedly parse the ASCII file
  save, z,r,ez,nz,nr, filename = restore_file

; *****************************************************************
; Here is the end of the if/then/else construct for parsing.
; *****************************************************************
endelse

; *****************************************************************
; Scale the data so it corresponds to the desired units and set the labels
; *****************************************************************
;
; Set first the default labels which correspond to length along
; the firts coordinate axis and a k-vector along the second.
; This is the case of no scaling. 
; 
q1_label = x1Label
q2_label = '!3k!d' + x2Label + '!n'
x_label  = q1_label + ' [microns]'
z_label  = '!3PSD(E!D' + EcomponentLabel + '!N) [arb. units]'
if ( ScaleFlag eq 1 ) then begin
  ;
  ; scale by the laser wave vector: omega_0/c, assuming that the
  ; ScaleInput is the laser wave frequency
  ; 
  omega_0 = ScaleInput
  K0 = omega_0/3.0e8
  z = z*1.e6
  ;r = r/K0
  ;y_label = q2_label + '/!3k!d0!n' 
  y_label = 'wavelength [nm]' 
endif else if (ScaleFlag eq 2) then begin
  ;
  ; scale the length using 1/Kp, Kp is the plasma wave vector
  ; 
  density = ScaleInput
  Kp = 2*acos(-1.0)*9000.0*sqrt(density)/3.0e8
  r = r/Kp
  y_label = q2_label + '/!3k!dp!n' 
endif else begin
  ;
  ; this is the default case of no scaling 
  ;
  y_label = q2_label + ' (rad/m)'
endelse

; *****************************************************************
; Specify minimum and/or maximum values for x1 and x2:
; *****************************************************************

; Set auto_scale_min to 1 (default choice) for automatic scaling
;    of x1min and x2min.
; Set auto_scale_max to 1 (default choice) for automatic scaling
;    of x1max and x2max.

; If you chose to set auto_scale_min or auto_scale_max to zero, then
;    you must provide the desired limits.

auto_scale_1min = 1
auto_scale_1max = 1
auto_scale_2min = 0
auto_scale_2max = 0

;
; set the min and max values of the wavelengh range in nm (these 
; correspond to the max and min values of the wavevector range which 
; we'll cut first and then convert to wavelength).
; 
waveLenMin = 400.
waveLenMax = 850.

pi2   = 2.*acos(-1.)
x1min = 0. 
x1max = 0.
x2min = pi2/(waveLenMax*1.e-9)
x2max = x2min*waveLenMax/waveLenMin

; 
; before converting the x2 points to wavelenghts we need to cut the
; the wavevector values to remove the 
print, ' '
print, 'After normalization of the z and r arrays:'
print, 'nz = ', nz
print, 'nr = ', nr
print, 'z(0) z(1) z(', nz-1, ') = ', z(0),z(1),z(nz-1)
print, 'r(0) r(1) r(', nr-1, ') = ', r(0),r(1),r(nr-1)

print, ' '
print, 'These are the min and max values of the original data:'

x1min_data = z(0)
x2min_data = r(0)
x1max_data = z(nz-1)
x2max_data = r(nr-1)

help,x1min_data
help,x1max_data
help,x2min_data
help,x2max_data

if (auto_scale_1min ne 0) then begin
  x1min = x1min_data
endif

if (auto_scale_2min ne 0) then begin
  x2min = x2min_data
endif

if (auto_scale_1max ne 0) then begin
  x1max = x1max_data
endif

if (auto_scale_2max ne 0) then begin
  x2max = x2max_data
endif

print, ' '
print, 'These are the specified min and max values:'

help,x1min
help,x1max
help,x2min
help,x2max

; *****************************************************************
; Surface plots don't support xrange/yrange, so truncate the data:
; *****************************************************************
if ( (x1min gt x1min_data) or (x2min gt x2min_data) ) then begin
  struct_A = array_cut(z, r, ez, x1min, x2min)
  z  = struct_A.xnew
  r  = struct_A.ynew
  ez = struct_A.znew

  nz = n_elements(z)
  nr = n_elements(r)

  print, ' '
  print, 'After applying the specified x1min and x2min --'
  print, 'nz = ', nz
  print, 'nr = ', nr
  print, 'z(0) z(1) z(', nz-1, ') = ', z(0),z(1),z(nz-1)
  print, 'r(0) r(1) r(', nr-1, ') = ', r(0),r(1),r(nr-1)
endif

if ( (x1max lt x1max_data) or (x2max lt x2max_data) ) then begin
  struct_A = array_cut_max(z, r, ez, x1max, x2max)
  z  = struct_A.xnew
  r  = struct_A.ynew
  ez = struct_A.znew

  nz = n_elements(z)
  nr = n_elements(r)

  print, ' '
  print, 'After applying the specified x1max and x2max --'
  print, 'nz = ', nz
  print, 'nr = ', nr
  print, 'z(0) z(1) z(', nz-1, ') = ', z(0),z(1),z(nz-1)
  print, 'r(0) r(1) r(', nr-1, ') = ', r(0),r(1),r(nr-1)
endif

; 
; transform the wavevector data to wavelength
; 
normFactor = pi2*1.e9
rtmp = dblarr(nr)
for i = 0, nr-1 do begin
    rtmp(i) = normFactor/r(i)
endfor
r = rtmp
print, 'r(0) r(1) r(', nr-1, ') = ', r(0),r(1),r(nr-1)
; *****************************************************************
; Create a 2-D color map appropriate for the surface
; *****************************************************************

; Create a 2D array that specifies the color for each grid point
ez_log = alog(ez)
if (log_plot_flag eq 0) then begin
  ez_color=ez-min(ez)
  ez_color=ez_color/max(ez_color)
  ez_color=ez_color*255.
endif else begin
  ez_color=ez_log-min(ez_log)
  ez_color=ez_color/max(ez_color)
  ez_color=ez_color*255.
endelse

; *****************************************************************
; Loop for rendering 2-D B&W contour plot on screen and to a file
; *****************************************************************

if (doContour eq 1) then begin

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Contour plot will appear in window ', window_number
  window, window_number
  contour_i = 0
  contour_jump:

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    print, ' '
    print, 'Writing the 2D b&w contour plot to file ' + ps_cont_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D b&w contour plot to the screen...'
  endelse
  
  print, 'min_x1  = ' , min(z)
  print, 'max_x1  = ' , max(z)
  print, 'min_x2  = ' , min(r)
  print, 'max_x2  = ' , max(r)

if (log_plot_flag eq 0) then begin
  contour, ez, z, r, thick=2, /xs, /ys, nlevels=4, xtitle=x_label, ytitle=y_label
endif else begin
  print, 'max_ez_log = ', max(ez_log)
  print, 'min_ez_log = ', min(ez_log)
  contour, ez_log, z, r, thick=2, /xs, /ys, nlevels=4, xtitle=x_label, ytitle=y_label
endelse


; rendering to screen is done.  here we render to ps file
  if (contour_i eq 0) then begin
    contour_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_cont_file
    goto, contour_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (contour_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif


; *****************************************************************
; Loop for rendering 2-D color contour plot on screen and to a file
; *****************************************************************

if (doColorCon eq 1) then begin

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Color contour plot will appear in window ', window_number
  window, window_number
  ccontour_i = 0
  ccontour_jump:

; Load in the STD GAMMA-II color table
  loadct, 5

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    print, ' '
    print, 'Writing the 2D color contour plot to file ' + ps_ccon_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D color contour plot to the screen...'
  endelse

if (log_plot_flag eq 0) then begin
  contour, ez, z, r, thick=2, /xs, /ys, nlevels=100, xtitle=x_label, ytitle=y_label, /fill
endif else begin
  contour, ez_log, z, r, thick=2, /xs, /ys, nlevels=256, xtitle=x_label, ytitle=y_label, MIN_VALUE=28.0, MAX_VALUE=52.0, /fill
endelse

; rendering to screen is done.  here we render to ps file
  if (ccontour_i eq 0) then begin
    ccontour_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_ccon_file, /color, bits_per_pixel=8
    goto, ccontour_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (ccontour_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif


; *****************************************************************
; Loop for rendering color surface plot on screen and to a file
; *****************************************************************

if (doSurface eq 1) then begin

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Color surface plot will appear in window ', window_number
  window, window_number
  surface_i = 0
  surface_jump:

; Load in the STD GAMMA-II color table
  loadct, 5

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    print, ' '
    print, 'Writing the color surface plot to file ' + ps_surf_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0 
    device,decomposed=0
    print, ' '
    print, 'Rendering the color surface plot to the screen...'
  endelse

  xAng = 50;
  zAng = 30;

if (log_plot_flag eq 0) then begin
  surface, ez, z, r, thick=2, /xs, /ys, ax=xAng, az=zAng, shades=ez_color, $
           xtitle=x_label, ytitle=y_label, ztitle=z_label
endif else begin
  surface, ez, z, r, thick=2, /xs, /ys, ax=xAng, az=zAng, shades=ez_color, $
           xtitle=x_label, ytitle=y_label, ztitle=z_label, /zlog
endelse

; rendering to screen is done.  here we render to ps file
  if (surface_i eq 0) then begin
    surface_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_surf_file, /color, bits_per_pixel=8
    goto, surface_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (surface_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif


; *****************************************************************
; Repeat simple plot loop for generating fancy 3-tiered plot.
; *****************************************************************

if (doShow3D eq 1) then begin

; Get a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Three-tiered plot will appear in window ', window_number
  window, window_number
  three_tiered_i = 0
  three_tiered_jump:

; Load in the STD GAMMA-II color table
  loadct, 5

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    print, ' '
    print, 'Writing 3-tiered surface/contour plot to file ' + ps_tier_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
    print, ' '
    print, 'Rendering the 3-tiered surface/contour plot to the screen...'
  endelse

  surface_struct = { shades:ez_color, xtitle:x_label, ytitle:y_label, ztitle:z_label, $
                     xstyle:1, ystyle:1, zstyle:1}
  contour_struct = { nlevels:6, xstyle:1, ystyle:1, zstyle:1}
  show3, ez, z, r, e_surface=surface_struct, e_contour=contour_struct

; rendering to screen is done.  here we render to ps file
  if (three_tiered_i eq 0) then begin
    three_tiered_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_tier_file, /color, bits_per_pixel=8
    goto, three_tiered_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (three_tiered_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif

; *****************************************************************
; Repeat simple plot loop for generating 2-D lineout plots.
; *****************************************************************

if (doLineout eq 1) then begin
;
; First, grab the desired column of data, the z array corresponds to
; the first coordinate and the r array to the second one, i.e. to
; rows and columns.
; Specify which column of grid points to use with the z_factor.
; Set the z_factor (between 0 and 1) specifying which column of data
; should appear in the plot.
;
  z_factor = 0.5
  z_column = fix(nz*z_factor)
  ez_line = ez(z_column,*)

  print, ' '
  print, 'z_column = ', z_column
  help, ez_line

;
; calculate the 10% level
;
  ez_lineMax = max(ez_line)
  ez_lineMin = ez_lineMax/10000.
  ez_level   = ez_lineMax/10.
  whez   = where( ez_line gt ez_level )
  numHighInd = n_elements(whez)
  y1 = ez_line(whez(numHighInd-1)+1)
  x1 = r(whez(numHighInd-1)+1)
  y2 = ez_line(whez(numHighInd-1))
  x2 =  r(whez(numHighInd-1))
  a0 = (x2*y1 - x1*y2)/(x2 - x1)
  a1 = (y2 - y1)/(x2 - x1)
  xlevel = (ez_level - a0)/a1
  print, 'Blue shift = ', xlevel

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Line plot will appear in window ', window_number
  window, window_number
  lineout_i = 0
  lineout_jump:

; Load in the STD GAMMA-II color table
  loadct, 5

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    print, ' '
    print, 'Writing the 2D lineout plot to file ' + ps_line_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D lineout plot for the screen...'
  endelse

if (log_plot_flag eq 0) then begin
  ;plot, r, ez_line, thick=2, /xs, xtitle=y_label, ytitle=z_label, yrange=[ez_lineMin, ez_lineMax]
  plot, r, ez_line, thick=2, /xs, xtitle=y_label, ytitle=z_label, xrange=[waveLenMin, waveLenMax], yrange=[ez_lineMin, ez_lineMax]
  PlotS, [xlevel, xlevel], [ez_lineMin, ez_lineMax], lineStyle = 1
  PlotS, [xlevel, xlevel], [ez_lineMin, ez_lineMax], lineStyle = 1
endif else begin
  ;plot_io, r, ez_line, thick=2, /xs, xtitle=y_label, ytitle=z_label, yrange=[ez_lineMin, ez_lineMax]
  plot_io, r, ez_line, thick=2, /xs, xtitle=y_label, ytitle=z_label, xrange=[waveLenMin, waveLenMax], yrange=[ez_lineMin, ez_lineMax]
  PlotS, [waveLenMin, waveLenMax], [ez_level, ez_level], lineStyle = 1
  PlotS, [xlevel, xlevel], [ez_lineMin, ez_lineMax], lineStyle = 1 
  ;strout = '10 % level = ' + Fix(xlevel)
  ;XYOutS, 0.3, 0.7, strout, Size=2., /Normal
  XYOutS, 0.3,  0.7, '10 % level = ', Size=2., /Normal
  XYOutS, 0.46, 0.7, Fix(xlevel),  Size=2., /Normal
  XYOutS, 0.57, 0.7, '(nm)', Size=2., /Normal
endelse

; rendering to screen is done.  here we render to ps file
  if (lineout_i eq 0) then begin
    lineout_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_line_file, /color, bits_per_pixel=8
    goto, lineout_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (lineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif

; *****************************************************************
; Do a line plot of the inegrated along "y" power spectral density
; *****************************************************************

if (doIntegral eq 1) then begin
  nzFraction = 0.45  
  nzMin = fix(nzFraction*nz)
  nzMax = fix((1.-nzFraction)*nz) - 1
  if ( (nzMax + 1) eq nzMin ) then begin
    nzMax = nzMin
  endif 
  ;
  ; sum up along "y" 
  ; 
  psd_1d = dblarr(nr)
  for i = 0, nr-1 do begin
    psd_1d(i) = 0.
    for j = nzMin, nzMax do begin
      psd_1d(i) = psd_1d(i) + ez(j,i)
    endfor
  endfor

;  max_tmp = max(psd_1d)
;  psd_1d = psd_1d * max(ez) / max_tmp
;  ez_line = psd_1d 
  ez_line = psd_1d/(nzMax - nzMin + 1)

;
; calculate the 10% level
;
  ez_lineMax = max(ez_line)
  ez_lineMin = ez_lineMax/10000.
  ez_level   = ez_lineMax/10.
  whez   = where( ez_line gt ez_level )
  numHighInd = n_elements(whez)
  print, 'whez(numHighInd-1)+1 = ', whez(numHighInd-1)+1
  y1 = ez_line(whez(numHighInd-1)+1)
  x1 = r(whez(numHighInd-1)+1)
  y2 = ez_line(whez(numHighInd-1))
  x2 =  r(whez(numHighInd-1))
  a0 = (x2*y1 - x1*y2)/(x2 - x1)
  a1 = (y2 - y1)/(x2 - x1)
  xlevel = (ez_level - a0)/a1
  print, 'Blue shift = ', xlevel

; Put the plot into a new window
  window_number = !d.window + 1
  print, ' '
  print, 'Line plot will appear in window ', window_number
  window, window_number
  lineout_i = 0
  integral_jump:

; Load in the STD GAMMA-II color table
  loadct, 5

; Specify a font that looks great for printing (crappy on screen),
;   or else one that looks OK on the screen (also OK for printing).
  if (!d.name eq 'PS') then begin
    !p.font=1
    !p.charsize=1.6
    !p.charthick=1.5
    print, ' '
    print, 'Writing the 2D lineout plot to file ' + ps_line_file
  endif else begin
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
    print, ' '
    print, 'Rendering the 2D lineout plot for the screen...'
  endelse

if (log_plot_flag eq 0) then begin
  ;plot, r, ez_line, thick=2, /xs, xtitle=y_label, ytitle=z_label, yrange=[ez_lineMin, ez_lineMax]
  plot, r, ez_line, thick=2, /xs, xtitle=y_label, ytitle=z_label, $
    xrange=[waveLenMin, waveLenMax], yrange=[ez_lineMin, ez_lineMax], $
    Title='Averaged 1d Power Spectral Density'
  PlotS, [xlevel, xlevel], [ez_lineMin, ez_lineMax], lineStyle = 1
  PlotS, [xlevel, xlevel], [ez_lineMin, ez_lineMax], lineStyle = 1
endif else begin
  ;plot_io, r, ez_line, thick=2, /xs, xtitle=y_label, ytitle=z_label, yrange=[ez_lineMin, ez_lineMax]
  plot_io, r, ez_line, thick=2, /xs, xtitle=y_label, ytitle=z_label, $
    xrange=[waveLenMin, waveLenMax], yrange=[ez_lineMin, ez_lineMax], $
    Title='Averaged 1d Power Spectral Density'
  PlotS, [waveLenMin, waveLenMax], [ez_level, ez_level], lineStyle = 1
  PlotS, [xlevel, xlevel], [ez_lineMin, ez_lineMax], lineStyle = 1 
  ;strout = '10 % level = ' + Fix(xlevel)
  ;XYOutS, 0.3, 0.7, strout, Size=2., /Normal
  XYOutS, 0.3,  0.7, '10 % level = ', Size=2., /Normal
  XYOutS, 0.46, 0.7, Fix(xlevel),  Size=2., /Normal
  XYOutS, 0.57, 0.7, '(nm)', Size=2., /Normal
endelse

; rendering to screen is done.  here we render to ps file
  if (lineout_i eq 0) then begin
    lineout_i = 1
    set_plot, 'PS', /copy
    device, filename = ps_integral_file, /color, bits_per_pixel=8
    goto, integral_jump  
  endif

; here rendering to file is done.  set back to screen defaults
  if (lineout_i eq 1) then begin
    device, /close
    set_plot, 'X'
    !p.font=-1
    !p.charsize=2.0
    device,decomposed=0
  endif

endif

; *****************************************************************
; Final clean-up
; *****************************************************************

; Stop here so that all variables will still be in scope.
; stop

; All done.
end





; *****************************************************************
; checkComponent procedure
; *****************************************************************

pro checkComponent, componentLabel, component

  CASE ComponentLabel OF
    ; if componentLabel is 'x' 
    'x': print, "Setting "+component+" label to "+ComponentLabel

    ; 'y'
    'y': print, "Setting "+component+" label to "+ComponentLabel

    ; 'r'
    'r': print, "Setting "+component+" label to "+ComponentLabel
                         
    ; 'z'                
    'z': print, "Setting "+component+" label to "+ComponentLabel

    ; no matches => print warning
  ELSE: print, "WARNING: Component label is not in the set (x, y, r, z)!?"
  ENDCASE
end
